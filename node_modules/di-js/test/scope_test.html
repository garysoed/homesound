<!DOCTYPE html>
<html>
<head>
  <base href=".">
  <title>BindingTree Unit Tests</title>

  <link rel="import" href="testutils.html">

  <link rel="import" href="../node_modules/spies/main_chai_expect.html">

  <script src="bin.js"></script>
</head>
<body>
  <script lang="es6">
  const Scope = DIJS.Scope;

  let expect = chai.expect;

  describe('Scope', () => {
    let scope;
    let __resolve__;

    beforeEach(() => {
      scope = new Scope('(root)', null /* provider */, new Map());
      __resolve__ = t.getSymbol(Scope.prototype, 'resolve');
    });

    describe('#with', () => {
      it('should return a child scope with the given provider bound', () => {
        let provider = () => 1;
        let childScope = scope.with('name', provider);

        expect(t.getSymbolValue(childScope, 'provider')).to.equal(provider);
        expect(t.getSymbolValue(childScope, 'name')).to.equal('name');
        expect(t.getSymbolValue(childScope, 'parentScope')).to.equal(scope);
        expect(t.getSymbolValue(childScope, 'globalBindings'))
            .to.equal(t.getSymbolValue(scope, 'globalBindings'));
      });
    });

    describe('#constant', () => {
      it('should return a child scope with the given constant bound', () => {
        let childScope = scope.constant('name', 1);

        expect(t.getSymbolValue(childScope, 'provider')()).to.equal(1);
        expect(t.getSymbolValue(childScope, 'name')).to.equal('name');
        expect(t.getSymbolValue(childScope, 'parentScope')).to.equal(scope);
        expect(t.getSymbolValue(childScope, 'globalBindings'))
            .to.equal(t.getSymbolValue(scope, 'globalBindings'));
      });
    });

    describe('#bind', () => {
      it('should bind the provider to the root scope', () => {
        let provider = () => 1;
        let descendant = scope.constant('a', 1).constant('b', 2);
        descendant.bind('c', provider);

        let bindScope = t.getSymbolValue(scope, 'globalBindings').get('c');
        expect(t.getSymbolValue(bindScope, 'provider')).to.equal(provider);
      });
      it('should return the current scope', () => {
        expect(scope.bind('a', () => 1)).to.equal(scope);
      });
      it('should throw error if a key is being bound twice', () => {
        scope.bind('a', () => 1);

        expect(() => { scope.bind('a', () => 2); }).to.throw('already bound');
      });
    });

    describe('#run', () => {
      it('should pass a require and optional function into the provider function', done => {
        scope.run((require, optional) => {
          expect(require).to.be.instanceof(Function);
          expect(optional).to.be.instanceof(Function);
          done();
        });
      });
    });

    describe('#export', () => {
      it('should create the hierarchy when exporting the object', () => {
        scope
            .bind('a', () => 2)
            .export('a', 'testData.a.b.c');

        expect(window.testData.a.b.c).to.equal(2);
      });

      afterEach(() => {
        delete window.testData;
      });
    });

    describe('#__resolve__', () => {
      it('should return key in the global binding', () => {
        let globalBindings = new Map();
        globalBindings.set('key', new Scope('(root)', () => 1, globalBindings));

        let scope = new Scope('test', null /* provider */, globalBindings);
        expect(scope[__resolve__]('key')).to.equal(1);
      });
      it('should prefer key in the running scope', () => {
        let globalBindings = new Map();
        globalBindings.set('key', new Scope('(root)', () => 1, globalBindings));

        let runningScope = new Scope('key', () => 2, globalBindings);
        let scope = new Scope('test', null /* provider */, globalBindings);
        expect(scope[__resolve__]('key', runningScope)).to.equal(2);
      });
      it('should prefer key in the ancestral scope', () => {
        let globalBindings = new Map();
        globalBindings.set('key', new Scope('(root)', () => 1, globalBindings));

        let runningScope = new Scope('key', () => 2, globalBindings);
        let parentScope = new Scope('key', () => 3, globalBindings);
        let scope = new Scope('test', null /* provider */, globalBindings, parentScope);
        expect(scope[__resolve__]('key', runningScope)).to.equal(3);
      });
      it('should return cached value', () => {
        let scope = new Scope('key', () => 2, new Map());
        let runContext = new Map();
        runContext.set(scope, 1);

        expect(scope[__resolve__]('key', this, runContext)).to.equal(1);
      });
      it('should throw error for cyclic dependency', () => {
        let searchChain = ['key'];
        let scope = new Scope('(root)', null /* provider */, new Map());

        expect(() => scope[__resolve__]('key', undefined, undefined, searchChain))
            .to.throw('key -> key');
      });
    });

    describe('#__searchAncestor__', () => {
      let __searchAncestor__;

      beforeEach(() => {
        __searchAncestor__ = t.getSymbol(Scope.prototype, 'searchAncestor');
      });

      it('should favor provider bound locally', () => {
        let child = scope.constant('a', 1);
        let grandChild = child.constant('a', 2);
        expect(grandChild[__searchAncestor__]('a')).to.equal(grandChild);
      });
      it('should fallback to provider bound in the parent scope', () => {
        let child = scope.constant('a', 1);
        let grandChild = child.constant('b', 2);
        expect(grandChild[__searchAncestor__]('a')).to.equal(child);
      });
      it('should return undefined if no provider is bound', () => {
        expect(scope[__searchAncestor__]('a')).to.be.undefined;
      });
    });
  });
  </script>
</body>
